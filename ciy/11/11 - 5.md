11.5 onToggle, onRemove 함수가 바뀌지 않게 하기
React.memo를 사용하는 것만으로 컴포넌트 최적화가 끝나지 않습니다. 현재 프로젝트에서는 todos 배열이 업데이트되면 onRemove와 onToggle 함수도 새롭게 바뀌기 때문입니다. onRemove와 onToggle 함수는 배열 상태를 업데이트하는 과정에서 최신 상태의 todos를 참조합니다. 때문에 todos 배열이 바뀔 때마다 함수가 새로 만들어집니다. 이렇게 함수가 계속 만들어지는 상황을 방지하는 방법은 두 가지입니다. 첫 번째 방법은 useState의 함수형 업데이트 기능을 사용하는 것이고, 두 번째 방법은 useReducer를 사용하는 것입니다.





11.5.1 useState의 함수형 업데이트
기존에 setTodos 함수를 사용할 때는 새로운 상태를 파라미터로 넣었습니다. setTodos를 사용할 때 새로운 상태를 파라미터로 넣는 대신 상태 업데이트를 어떻게 할지 정의해 주는 업데이트 함수를 넣을 수 있습니다. 이를 함수형 업데이트라고 부릅니다. onRemove와 onToggle, onIsert 함수에서 useState의 함수형 업데이트를 사용해 봅시다.

//기존 App.js
const onInsert = useCallback(
    text => {
      const todo = {
        id: nextId.current,
        text,
        checked: false,
      };
      setTodos(todos.concat(todo));
      nextId.current += 1;
    },
    [todos],
);

//수정한 App.js
const onInsert = useCallback(
    text => {
      const todo = {
        id: nextId.current,
        text,
        checked: false,
      };
      setTodos(todos=>todos.concat(todo));
      nextId.current += 1;
    },[]);
//기존
const onRemove = useCallback(
    id => {
      setTodos(todos.filter(todo => todo.id !== id));
    },[ todos],);

//수정
const onRemove = useCallback(
    id => {
      setTodos(todos=>todos.filter(todo => todo.id !== id));
    },[]);
//기존
const onToggle = useCallback(
    id => {
      setTodos(
        todos.map(todo =>
          todo.id === id ? { ...todo, checked: !todo.checked } : todo,
        ),
      );
    },
    [todos],
);

//수정
const onToggle = useCallback(
    id => {
      setTodos(todo =>
        todos.map(todo =>
          todo.id === id ? { ...todo, checked: !todo.checked } : todo,
        ),
      );
    },[]);


setTodos 안에 todos =>를 앞에 넣으면 됩니다. 이 코드를 저장하고 Profiler 개발자 도구로 성능을 측정합시다. 렌더링 소요시간이 358.4ms에서 20.7ms로 줄었습니다. 회색 빗금으로 그어져 있는 박스는 리렌더링되지 않은 컴포넌트를 나타냅니다. 차트 아이콘을 누르면 리렌더링된 컴포넌트의 수가 줄어든 것을 확인할 수 있습니다.


리렌더링되지 않아 회색 빗금으로 표시된 컴포넌트

리액트 개발자 도구의&nbsp; Profiler탭 - 좌측 상단 랭크 차트 아이콘 - 줄어든 리렌더링된 컴포넌트 수






11.5.2 useReducer 사용하기
useState의 함수형 업데이트를 사용하는 대신에 useReducer를 사용해도 onToggle과 onRemove가 새로워지는 문제를 해결할 수 있습니다. 이번에도 App.js 파일을 수정해 봅시다.

//import문 추가 작성
import { useReducer, useRef, useCallback } from 'react';

//App.js todoReducer 함수 작성
function todoReducer(todos, action) {
  switch (action.type) {
    case 'INSERT': // 새로 추가
      return todos.concat(action.todo);
    case 'REMOVE': // 제거
      return todos.filter(todo => todo.id !== action.id);
    case 'TOGGLE': // 토글
      return todos.map(todo =>
        todo.id === action.id ? { ...todo, checked: !todo.checked } : todo,
      );
    default:
      return todos;
  }
}

const App = () => {
  const [todos, dispatch] = useReducer(todoReducer, undefined, createBulkTodos);
  const nextId = useRef(2501);
  const onInsert = useCallback(
    text => {
      const todo = {
        id: nextId.current,
        text,
        checked: false,
      };
      dispatch({ type: 'INSERT', todo });
      //setTodos(todos=>todos.concat(todo));
      nextId.current += 1;
    },[]);

  const onRemove = useCallback(
    id => {
      dispatch({ type: 'REMOVE', id });
      //setTodos(todos=>todos.filter(todo => todo.id !== id));
    },[]);

  const onToggle = useCallback(
    id => {
      dispatch({ type: 'TOGGLE', id });
      //setTodos(todo =>
      //  todos.map(todo =>
      //    todo.id === id ? { ...todo, checked: !todo.checked } : todo,
      //  ),
      //);
    },[]);


useReducer를 사용하면 두 번째 파라미터에 초기 상태를 넣어야 합니다. 지금은 그 대신 undefined를 넣고 세 번째 파라미터에 초기 상태를 만드는 함수 createBulkTodos를 넣었습니다. 이러면 컴포넌트가 맨 처음 렌더링될 때만 createBulkTodos 함수가 호출됩니다.

이 코드를 저장하고 Profiler 개발자 도구로 성능을 측정합시다. 렌더링 소요시간이 358.4ms에서 11.6ms로 줄었습니다.


리액트 개발자 도구의&nbsp; Profiler탭 - 줄어든 렌더링 소요 시간
useReducer를 사용하면 기존 코드를 많이 고쳐야 하는 단점이 있으나 상태를 업데이트하는 로직을 모아서 컴포넌트 밖에 둘 수 있는 장점이 있습니다. 성능상으로는 useState의 함수형 업데이트를 사용하는 방법과 useReducer를 사용하는 방법이 비슷하기 때문에 취향에 따라 결정하면 됩니다.
