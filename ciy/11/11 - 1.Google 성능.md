1.
Google I/O는 Google이 캘리포니아 마운틴뷰에서 매년 개최하는 개발자 회의.
"I/O"라는 이름은 입력(input)/출력(output)의 약자

미국에서 개최한 개발자회의를 통해 정리된 결과물들을 각국각지에서 모임을 갖고있습니다.

  <br/>  <br/>


2. 
Google의 주요 Core Web Vitals (CWV) Opportunity는 <br/>
페이지의 로딩 성능, 상호작용성 및 시각적 안정성과 관련된 지표를 개선하여 <br/>
웹 페이지의 사용자 경험을 최적화하는 데 중점을 둡니다.  <br/>
<br/> <br/>

3.
Web Vitals(웹 바이탈) <br/>
<br/>
사용자 경험이 불편한 웹사이트는 <br/>
<br/>
사이트 이용시간을 단축시키거나, <br/>
재사용성을 떨어트릴 수 있습니다. <br/>
<br/>
서비스 운영자들은 웹 사이트를 이용하는 유저의 경험(UX, User Experience)을 향상시키기 위해 다양한 노력들을 기울이고 있고, <br/>
그래서 Web Vitals은 좋은 사용자 경험을 제공하기 위해 어떤 점을 개선시켜야 하는지에 대한 통합 최적화 지표입니다. <br/>
<br/><br/><br/>

4. <br/>
Chrome UX Report (CrUX), Lighthouse, PageSpeed Insights, Google Search Console과 같은 도구를 사용하여 이러한 지표를 측정할 수 있으며,<br/>
실제 사용자 경험과 시뮬레이션된 조건에 대한 통찰력을 제공하여 성능 문제를 식별하고 해결하는 데 도움이 됩니다.<br/>
<br/>
Largest Contentful Paint (LCP), First Input Delay (FID), Cumulative Layout Shift (CLS)가 포함됩니다.  <br/>


<br/><br/>
6.
Largest Contentful Paint (LCP) - 가장 큰 콘텐츠의 그리기:<br/>
최대 콘텐츠 렌더링 시간 (LCP): <br/>
로드 성능을 측정합니다. <br/>
우수한 사용자 환경을 제공하려면 페이지가 처음 로드되기 시작한 후 2.5초 이내에 LCP가 발생해야 합니다.<br/>
<br/>



LCP는 페이지 로딩 성능을 측정하는 지표로,<br/>
사용자가 페이지를 방문했을 때 가장 큰 콘텐츠(예: 이미지, 비디오 블록 등)가 화면에 나타나기까지의 시간을 말합니다.<br/>
이 지표는 페이지가 실제로 사용자에게 얼마나 빠르게 유용한 콘텐츠를 제공하는지를 나타냅니다.<br/>



<br/><br/>


Cumulative Layout Shift (CLS) - 누적 레이아웃 이동:<br/>
누적 레이아웃 변경 (CLS): <br/>
시각적 안정성을 측정합니다. 우수한 사용자 환경을 제공하려면 CLS를 0.1. 이하로 유지해야 합니다.<br/>
CLS는 시각적 안정성을 평가하는 지표로, <br/>
페이지가 로딩되는 동안 요소들이 얼마나 자주 및 예기치 않게 위치를 변경하는지 측정합니다.<br/>
이는 사용자가 페이지를 읽거나 사용할 때 예상치 못한 레이아웃 변경으로 인해 발생할 수 있는 혼란이나 불편을 나타냅니다.<br/>

First Input Delay (FID) - 첫 입력 지연:<br/>
FID는 상호작용성을 측정하는 지표로,<br/>
최초 입력 반응 시간 (FID): <br/>
상호작용을 측정합니다. <br/>
우수한 사용자 환경을 제공하려면 페이지의 FID가 100밀리초 이하여야 합니다.<br/>

FID는 2024년 3월에 Interaction to Next Paint (INP)로 대체될 예정입니다 <br/>
<br/>

INP
사용자가 페이지에서 어떤 동작(예: 링크 클릭, 버튼 누르기 등)을 했을 때 <br/>
그 페이지가 이에 반응하기까지의 지연 시간을 측정합니다.<br/>
이는 사용자가 페이지와 어떻게 상호작용할 수 있는지, 그리고 그 경험이 얼마나 반응적인지를 평가합니다.<br/>

<br/><br/>
로딩(Largest Contentful Paint, LCP), 상호작용(First Input Delay, FID), 시각적 안정성(Cumulative Layout Shift, CLS)

<br/><br/><br/>
이 세 지표는 모두 사용자 경험의 다양한 측면을 평가하며,<br/>
웹사이트 개발자는 이러한 지표를 통해 사용자 경험을 개선하기 위한 명확한 목표를 가질 수 있습니다.<br/>
Google은 이 지표들이 좋은 사용자 경험을 위한 임계값을 충족하는지를 기반으로 웹사이트의 성능을 평가하며,<br/>
이는 검색 엔진 최적화(SEO)에도 영향을 미칠 수 있습니다.<br/>




<br/><br/>
7.
Google은<br/>
각 CWV 지표를 '좋음', '개선 필요', '나쁨'으로 분류하기 위해 특정 임계값을 설정했습니다.<br/>


<br/><br/><br/><br/>



8.

LCP 설명시작!


LCP<br/><br/>최대 콘텐츠 렌더링 시간 측정<br/>

왼쪽부터 
- LCP 리소스가 HTML 소스에서 발견될 수 있도록 보장, 
- LCP 리소스가 우선 순위를 갖도록 보장,
- CDN을 사용하여 문서 및 리소스 LCP 최적화
  <br/><br/>
  LCP 리소스가 HTML 소스에서 발견될 수 있도록 보장<br/>
이 전략은 페이지의 LCP 요소(가장 큰 텍스트 블록 또는 이미지 등)가 브라우저가<br/><br/> 
가능한 한 빨리 해당 리소스를 찾고 로드하기 시작할 수 있도록 하는 것입니다. <br/>

<br/><br/>
예를 들어, 중요한 이미지 리소스를 HTML에 직접 포함시키거나, <br/>
초기 HTML 로드 과정에서 바로 찾을 수 있도록 배치하는 방법이 있습니다.<br/>




<br/><br/>
LCP 리소스가 우선 순위를 갖도록 보장<br/>
LCP 리소스가 브라우저에 의해 우선적으로 로드되도록 하는 것이 중요합니다. <br/>
이는 브라우저가 다른 비중요 리소스보다 중요한 LCP 리소스의 로딩에 더 많은 네트워크 리소스를 할당하도록 함으로써, <br/>
사용자가 페이지의 핵심 콘텐츠를 더 빠르게 볼 수 있게 합니다. <br/>
```html
<link rel="preload"> 
```
태그를 사용하여 특정 리소스를 사전에 로드하도록 지정하거나, <br/>
중요 스크립트와 CSS 파일의 로딩 순서를 조정하여 LCP 리소스의 로딩을 가속화할 수 있습니다.<br/>
<br/><br/>




CDN을 사용하여 문서 및 리소스 LCP 최적화<br/>
콘텐츠 전송 네트워크(Content Delivery Network, CDN)를 사용하면 <br/>
전 세계 여러 위치에 데이터 센터를 두고 사용자에게 가장 가까운 서버에서 <br/>
콘텐츠를 제공함으로써 문서와 리소스의 로드 시간을 단축할 수 있습니다. <br/>
이는 LCP 리소스를 비롯한 모든 페이지 콘텐츠의 로딩 속도를 향상시키는 데 도움이 됩니다. <br/>
CDN은 또한 콘텐츠 캐싱을 통해 더 빠른 재방문 로딩 속도를 제공하며, 전반적인 LCP 성능을 개선하는 데 중요한 역할을 합니다.<br/>

이러한 전략들을 적용함으로써, <br/>

웹사이트 개발자들은 사용자에게 더 나은 로딩 경험을 제공하고, <br/>
Google의 Core Web Vitals 중 하나인 LCP를 개선하여 검색 엔진 최적화(SEO) 성능을 향상시킬 수 있습니다.<br/>


<br/><br/> <br/> <br/> <br/> <br/> <br/> <br/> <br/> <br/> <br/> <br/> <br/>

9.

HTML 코드 스니펫은 웹 페이지에서 이미지를 로드하는 다양한 방식을 보여줍니다. <br/>
이러한 방식들은 브라우저의 사전 로드 스캐너에 의해 발견되거나 우선 순위가 지정되는 방식에 영향을 미칠 수 있으며, <br/>
이는 페이지의 로딩 성능과 Largest Contentful Paint (LCP) 지표에 영향을 줄 수 있습니다.<br/>
<br/><br/>
배경 이미지는 발견되지 않음
```html
<div style=”background-image: url(image-url.jpg)”>
```
이 코드는 CSS 스타일을 사용하여 div 요소에 배경 이미지를 설정합니다. <br/>
배경 이미지는 HTML의 <img> 태그와 달리 브라우저의 사전 로드 스캐너에 의해 발견되지 않습니다. <br/>
이는 브라우저가 페이지 로딩 초기 단계에서 이러한 이미지를 사전에 로드할 수 없음을 의미하며, <br/>
결과적으로 페이지 로드 시간에 영향을 줄 수 있습니다.<br/>
<br/><br/>


JavaScript를 사용하여 로드된 <img> 소스는 발견되지 않음
```html
<img data-src=”image-url.jpg” alt=”...”>
<img ng-src=”{{ image-url.jpg }}” alt=”...”>
```

이 예제들은 JavaScript 또는 AngularJS와 같은 프레임워크를 사용하여 이미지 소스를 동적으로 설정합니다.
이 방식으로 설정된 이미지는 HTML을 파싱할 때 바로 사용 가능한 상태가 아니기 때문에,
브라우저의 사전 로드 스캐너가 초기 로딩 과정에서 이를 발견할 수 없습니다.
사용자가 페이지에 상호작용하기 시작할 때까지 이미지 로딩이 지연될 수 있으며,
이는 LCP에 부정적인 영향을 줄 수 있습니다.

<br/><br/>


사전 로드 스캐너에서 무시되는 지연 로드 <img> 요소 <br/>
```html
<img src=”image-url.jpg” alt=”...” loading=”lazy”>
```

이 코드는 loading="lazy" 속성을 사용하여 이미지를 지연 로드합니다. <br/>
이 속성은 브라우저가 해당 이미지를 사용자 화면에 가까워질 때까지 로드를 지연시키도록 합니다. <br/>
지연 로딩은 '사용자가 즉시 보지 않는 콘텐츠의 로딩을 연기하여 초기 페이지 로드 성능을 개선'할 수 있지만, <br/>
LCP를 결정하는(최대 콘텐츠 렌더링 시간 측정) 중요한 이미지에 이 방법을 사용하면 LCP 성능이 저하될 수 있습니다. <br/>


 <br/> <br/> <br/>
또한, loading="lazy"로 설정된 이미지는 사전 로드 스캐너에 의해 무시되므로, <br/>
페이지 로딩의 초기 단계에서 우선적으로 로드되지 않습니다.<br/>
<br/>
이러한 각 방식은 이미지 로딩 전략과 성능 최적화에 있어 중요한 고려 사항입니다. <br/>
웹 개발자는 이러한 특성을 이해하고, 사용자 경험과 페이지 성능 간의 균형을 맞추기 위해 적절한 전략을 선택해야 합니다.<br/>
<br/>


<br/><br/><br/><br/><br/>

10.
LCP 성능 향상을 위한 해결방법

img 요소는 쉽게 발견됨 <br/>

```html
<img src='image-url.jpg' alt='...'>
```

이 코드는 가장 기본적인 형태로 이미지를 HTML 문서에 포함시키는 방법입니다.  <br/>
src 속성을 사용하여 이미지의 URL을 지정하면, 페이지가 로드될 때 브라우저가 이 이미지를 자동으로 발견하고 다운로드합니다. <br/>
이 방법은 이미지가 페이지 로딩 과정의 일부로 고려되어야 할 때 유용하며, 브라우저의 사전 로드 스캐너에 의해 쉽게 발견됩니다.  <br/>
따라서, 이 방식으로 로드된 이미지는 Largest Contentful Paint (LCP) 계산에 포함될 수 있습니다. <br/>
<br/> <br/><br/> <br/>
이미지를 사전 로드함으로써 발견 가능하게 만들기 <br/>
```html
<link rel=”preload” href=”image-url.jpg” as=”image”>
```
이 코드는 <link> 태그와 rel="preload" 속성을 사용하여 특정 리소스를 사전에 로드하도록 브라우저에 지시합니다. <br/> <br/> <br/>
as="image" 속성은 사전 로드할 리소스의 유형이 이미지임을 명시합니다. <br/> <br/> <br/>
사전 로드는 페이지의 핵심 리소스를 우선적으로 로드하고자 할 때 유용하며, <br/> <br/> <br/>
특히 LCP에 영향을 미칠 수 있는 중요한 이미지에 대해 사용됩니다. <br/>
이 방법은 브라우저가 페이지 로딩의 초기 단계에서 해당 이미지를 발견하고 우선 순위를 높여 로드하도록 합니다. <br/>
결과적으로, 사용자에게 더 빠른 콘텐츠 표시를 제공할 수 있습니다.<br/>
<br/>
이 두 방법은 웹 개발에서 이미지 로딩 전략을 결정할 때 고려해야 할 중요한 옵션입니다. <br/>
img 태그를 사용하는 것은 간단하고 직관적이며, 이미지가 페이지의 중요 부분일 경우 적합합니다. <br/>
반면, <link rel="preload">를 사용하는 사전 로드 방법은 페이지 성능을 최적화하고 LCP를 개선하려는 경우, <br/>
특히 초기 로딩 단계에서 중요한 이미지를 빠르게 로드해야 할 때 유용합니다.<br/>


<br/><br/><br/><br/><br/><br/>
fetchpriority 속성은 브라우저에게 특정 리소스의 로딩 중요도를 알려주어, <br/>
페이지 로딩 성능을 최적화하는 데 도움을 줍니다.<br/>
<br/><br/><br/>
fetchpriority를 사용하여 이미지 요소의 가져오기 우선 순위 추가<br/>
```html
<img src="image-url.jpg" alt="..." fetchpriority="high">
```
이 코드는 <img> 태그에 fetchpriority="high" 속성을 추가하여, 해당 이미지의 로딩 우선 순위를 높게 설정합니다. <br/><br/><br/>
이 속성은 브라우저에게 이 이미지가 중요하며 가능한 빨리 로드되어야 함을 알립니다. <br/><br/><br/>
특히, 페이지 로딩 시간에 큰 영향을 미치는 이미지나 사용자 경험에 중요한 이미지에 이 속성을 사용함으로써, <br/>
해당 이미지를 우선적으로 처리하고 더 빠르게 사용자에게 제공할 수 있습니다. <br/>
이는 Largest Contentful Paint (LCP) 지표 개선에도 기여할 수 있습니다.<br/>
<br/><br/><br/><br/>
사전 로드에 fetchpriority 속성 사용
```html
<link rel="preload" href="image-url.jpg" as="image" fetchpriority="high">
```
이 코드는 <link> 태그와 rel="preload" 속성을 사용해 특정 이미지를 사전 로드하도록 하며,  <br/>
fetchpriority="high" 속성을 추가해 이 리소스의 로딩 우선 순위를 높입니다.  <br/><br/><br/>
이 방식은 페이지의 초기 로딩 단계에서 중요한 이미지 리소스를  <br/>
빠르게 로드하기 위해 브라우저에게 명시적인 우선 순위를 지정합니다.  <br/>
결과적으로, 중요한 콘텐츠가 사용자에게 더욱 신속하게 표시되어 전반적인 페이지 로딩 성능과 사용자 경험이 개선됩니다. <br/>

fetchpriority 속성은 웹 성능 최적화에 있어 중요한 도구로,  <br/>
개발자가 리소스 로딩의 우선 순위를 더 세밀하게 제어할 수 있게 합니다.  <br/>
이를 통해 중요한 리소스가 적절한 시기에 로드되도록 보장하며,  <br/>
불필요한 로딩 지연을 방지하여 사용자 경험을 향상시킬 수 있습니다. <br/>



 <br/> <br/> <br/>
11.

CLS 설명시작!


CLS(누적 레이아웃 이동)

왼쪽에서부터 
- 페이지에서 로드된 모든 콘텐츠에 명시적 크기 설정, 
- 페이지가 BFCache에 적합하도록 보장, 
- 레이아웃을 유발하는 CSS 속성을 사용한 애니메이션/전환 피하기)

페이지에서 로드된 모든 콘텐츠에 명시적 크기 설정 <br/><br/>
웹 페이지에서 이미지, 비디오, 광고 프레임 등 모든 콘텐츠에 대해 <br/>
명시적인 width와 height 속성을 설정하는 것이 중요합니다.  <br/>
이렇게 하면 브라우저가 페이지를 로드할 때 콘텐츠의 정확한 크기를 미리 알 수 있어, <br/>
페이지 레이아웃을 계산하는 데 필요한 리소스를 절약할 수 있습니다. <br/>
또한, 이는 불필요한 레이아웃 이동을 방지하여 Cumulative Layout Shift (CLS)를 줄이는 데 도움이 됩니다. <br/>
콘텐츠의 크기를 미리 정의하면, 콘텐츠가 로드되는 동안 사용자에게 보이는 페이지의 변화를 최소화하여 더 안정적인 사용자 경험을 제공할 수 있습니다.<br/>

<br/><br/><br/><br/>

페이지가 BFCache에 적합하도록 보장<br/><br/>
BFCache(Back/Forward Cache)는 사용자가 브라우저의 뒤로 가기 및 앞으로 가기 버튼을 사용할 때 <br/>
이전에 방문했던 페이지를 빠르게 로드하기 위한 브라우저의 캐싱 기술입니다. <br/>
페이지가 BFCache에 적합하도록 만드는 것은 페이지 로드 시간을 크게 줄이고 사용자 경험을 향상시킬 수 있습니다. <br/>
페이지를 BFCache에 적합하게 만들기 위해서는 페이지가 동적으로 변경되지 않는 구조여야 하며, <br/>
사용자 세션 정보나 실시간 데이터를 로드하는 스크립트 사용을 피해야 합니다. <br/>
또한, unload 이벤트 리스너의 사용을 피하는 것이 좋습니다.

레이아웃을 유발하는 CSS 속성을 사용한 애니메이션/전환 피하기<br/>
애니메이션과 전환은 웹 페이지에 동적인 요소를 추가하여 사용자 경험을 풍부하게 할 수 있지만, <br/>
레이아웃을 변경하는 CSS 속성(width, height, margin 등)을 사용하면 브라우저가 추가적인 레이아웃 계산을 수행해야 하므로 성능에 부정적인 영향을 줄 수 있습니다.  <br/>
특히, 이러한 계산은 CLS 점수를 악화시키고 사용자 경험을 저해할 수 있습니다.  <br/>
transform과 opacity와 같이 레이아웃 계산을 유발하지 않는 속성을 사용하여 애니메이션을 구현하는 것이 성능에 더 좋습니다.  <br/>
이러한 속성은 GPU 가속을 활용할 수 있어 더 부드러운 애니메이션 효과를 제공하면서도 성능 저하를 최소화합니다. <br/>





12.
 <br/> <br/>
크기 없는 이미지로 인한 CLS 발생

```html
<img src="image-url.jpg" alt="...">
```
이 코드는 width와 height 속성이 명시되지 않은 채로 이미지를 로드합니다. <br/>
이미지의 실제 크기가 브라우저에 미리 알려지지 않기 때문에, <br/>
이미지가 로드되고 레이아웃에 삽입될 때까지 페이지의 다른 콘텐츠가 잠재적으로 이동할 수 있습니다. <br/>
이러한 동적인 레이아웃 변화는 CLS를 증가시켜 사용자에게 불편을 줄 수 있습니다.<br/>
<br/><br/>
너비와 높이를 명시적으로 설정<br/>
```html
<img src="image-url.jpg" alt="..." width="400" height="200">
```
이 코드는 이미지에 width와 height 속성을 추가하여 명시적인 크기를 설정합니다. <br/>
이렇게 하면 브라우저가 이미지를 로드하기 전에 이미지가 차지할 공간의 크기를 미리 알 수 있게 되어, <br/>
페이지 로딩 초기부터 해당 공간을 예약할 수 있습니다. <br/>
결과적으로, 이미지가 로드되어도 페이지의 레이아웃이 변경되지 않으므로 CLS 문제를 방지할 수 있습니다.<br/>

<br/><br/>

개발자는 비디오 콘텐츠가 다양한 디스플레이 크기에서도 일관된 비율로 표시되도록 할 수 있습니다.<br/>

코드 설명
```css
video {
  width: 100%;
  height: auto;
  aspect-ratio: 16/9;
}
```
width: 100%;: <br/>
비디오의 너비를 부모 요소의 100%로 설정하여, 비디오가 포함된 컨테이너의 전체 너비를 차지하도록 합니다. <br/>
이는 비디오가 반응형으로 동작하게 하여, 다양한 화면 크기에서도 가로 너비에 맞게 자동으로 조정됩니다.<br/>
<br/>
height: auto;: <br/>
비디오의 높이를 자동으로 설정하여, 비디오의 가로 세로 비율이 유지되도록 합니다. <br/>
이는 비디오의 실제 높이를 비디오의 너비와 설정된 가로 세로 비율에 따라 자동으로 조정합니다.<br/>
<br/>
aspect-ratio: 16/9;: <br/>
비디오의 가로 세로 비율을 16:9로 명시적으로 설정합니다. <br/>
이 속성은 비디오의 너비와 높이 사이의 비율을 정의하며, 비디오가 이 비율을 유지하도록 보장합니다. <br/>
이는 화면의 크기가 변해도 비디오의 비율이 왜곡되지 않게 해 주며, 사용자에게 일관된 시청 경험을 제공합니다.<br/>
<br/>
이러한 방식으로 비디오를 스타일링하면, <br/>
개발자는 반응형 웹 디자인에서 중요한 가로 세로 비율을 유지하면서도, <br/>
다양한 디바이스와 화면 크기에 맞게 비디오 콘텐츠를 쉽게 적용할 수 있습니다. <br/>
이는 사용자 경험을 개선하고, 시각적으로 안정적인 웹 페이지 디자인을 구현하는 데 도움이 됩니다.<br/>



<br/><br/>






브라우저의 뒤로/앞으로 캐시(bfcache, Back/Forward Cache)는 사용자가 뒤로 가기 또는 앞으로 가기 버튼을 사용할 때 <br/>
이전에 방문했던 페이지를 완전히 렌더링된 상태로 캐시에 저장하여, 해당 페이지를 다시 방문할 때 빠르게 로드할 수 있도록 하는 기술입니다. <br/>
이 기능은 웹사이트 탐색 속도를 크게 향상시킬 수 있으며, 사용자 경험을 개선하는 데 도움이 됩니다.<br/>

bfcache를 활용하면, 페이지를 새로 로드할 필요 없이 즉시 이전 상태로 복원할 수 있어, <br/>
네트워크 요청이나 데이터 처리가 필요 없게 됩니다.  <br/>
이는 특히 모바일 환경에서 데이터 사용량을 줄이고, 로딩 시간을 단축하는 데 유용합니다.<br/>

그러나 모든 페이지가 자동으로 bfcache에 저장되는 것은 아닙니다. <br/>
페이지가 bfcache에 저장되기 위해서는, 브라우저가 정한 특정 조건을 만족해야 합니다. <br/>
예를 들어, 페이지가 동적으로 변경되는 콘텐츠를 포함하지 않거나, <br/>
사용자 세션에 의존하지 않아야 하며, unload 이벤트 리스너와 같은 특정 자바스크립트 이벤트를 사용하지 않아야 합니다.<br/>

웹 개발자는 페이지가 bfcache를 활용할 수 있도록 최적화하는 것을 고려해야 합니다. <br/>
이는 페이지의 로드 시간을 줄이고, <br/>
사용자가 사이트를 탐색할 때 더 부드러운 경험을 제공함으로써 전반적인 웹사이트 성능을 향상시키는 방법 중 하나입니다.<br/>

 <br/> <br/> <br/> <br/> <br/> <br/> <br/> <br/>
호환성 문제: 모든 브라우저가 BFCache를 동일한 방식으로 구현하거나 지원하지 않습니다. 따라서 웹 개발자는 다양한 브라우저에서 일관된 사용자 경험을 제공하기 위해 추가 작업을 해야 할 수 있습니다.

보안 문제: 사용자가 입력한 데이터나 상호 작용 내역이 캐시에 저장되면, 이러한 정보가 노출될 위험이 있습니다. 예를 들어, 사용자가 폼에 입력한 정보가 BFCache에 저장되어 있다가 다른 사용자에게 노출될 수 있습니다.

메모리 사용량 증가: BFCache는 사용자가 방문했던 페이지의 상태를 메모리에 저장해 둡니다. 이로 인해 브라우저의 메모리 사용량이 증가할 수 있으며, 이는 특히 메모리 자원이 제한적인 모바일 장치에서 문제가 될 수 있습니다.

최신 상태 유지의 어려움: BFCache에 저장된 페이지는 사용자가 마지막으로 방문했을 때의 상태를 유지합니다. 만약 웹 사이트의 내용이 사용자가 페이지를 캐시에 저장한 이후 변경되었다면, 사용자는 최신 내용을 보지 못할 수 있습니다.

자바스크립트 실행 문제: BFCache에서 페이지를 복원할 때, 일부 자바스크립트 실행이 예상대로 동작하지 않을 수 있습니다. 예를 들어, 페이지가 캐시에서 복원될 때 일부 스크립트가 재실행되지 않아 웹 애플리케이션의 동작에 영향을 줄 수 있습니다.

 <br/> <br/> <br/>
Cache-Control: no-store를 Response header에 지정한다는 것은 <br/>
웹 서버가 클라이언트(예: 웹 브라우저)나 중간 캐시 서버들에게 해당 리소스를 저장하지 말라는 지시를 내리는 것을 의미합니다. <br/>
이 지시는 특히 민감한 정보를 다루는 페이지나 리소스에 사용되며, 이를 통해 보안을 강화할 수 있습니다.<br/>
<br/>
웹에서 캐싱은 자주 사용되는 데이터를 임시 저장소에 보관하여, 같은 요청이 들어왔을 때 빠르게 응답할 수 있도록 하는 기술입니다. <br/>
하지만, 민감한 정보가 포함된 데이터를 캐싱하게 되면, 누군가가 그 캐시에 접근하여 정보를 불법적으로 얻을 수 있는 위험이 있습니다.<br/>

Cache-Control: no-store 지시어를 사용하면, <br/>
해당 응답 데이터가 어디에도 저장되지 않아야 함을 의미합니다. <br/>
따라서, 이 지시어가 포함된 응답은 메모리 내에서만 처리되고, 디스크에는 기록되지 않아야 합니다. <br/>
이를 통해 보안을 강화하고, 사용자의 민감한 정보를 보호할 수 있습니다.<br/>

<br/>

```html
<meta http-equiv="Cache-Control" content="no-store" />
```
사용 중인 웹 서버나 프로그래밍 언어, 프레임워크에 따라 적용 방법이 다를 수 있습니다. <br/>




<br/><br/><br/><br/><br/><br/>
13.
FID 설명 시작!

First Input Delay(FID)


FID는 2024년 3월에 Interaction to Next Paint (INP)로 대체될 예정입니다 <br/>
INP 사용자가 페이지와 상호작용(예: 클릭, 탭, 키 입력)한 후 브라우저가 해당 상호작용에 대한 응답으로 화면을 다시 그리기까지 걸린 시간을 측정


 <br/> <br/> <br/> <br/> <br/> <br/>

Prefetching과 Prerendering은 웹사이트의 Core Web Vitals(CWV)을 개선하는 데 도움이 될 수 있는 기술입니다. <br/>
Prefetching과 Prerendering은 사용자가 실제로 요청하기 전에 데이터나 페이지를 미리 로드함으로써 이러한 지표들을 개선할 수 있습니다.<br/>

Prefetching<br/>
Prefetching은 사용자가 다음에 방문할 가능성이 높은 웹 페이지나 리소스를 미리 다운로드하여 브라우저 캐시에 저장하는 기술입니다. <br/>
이를 통해 사용자가 해당 페이지나 리소스에 접근할 때 로딩 시간을 줄일 수 있습니다. <br/>
Prefetching에는 여러 종류가 있으며, 주로 다음 두 가지 방법이 사용됩니다:<br/>

Link Prefetching: <br/>
사용자가 다음에 방문할 페이지의 URL을 미리 알고 있을 때 사용합니다.  <br/>
```html
<link rel="prefetch" href="URL"> 
```
태그를 사용하여 구현할 수 있습니다. <br/>
<br/><br/><br/><br/
DNS Prefetching:  <br/>
웹 페이지에서 참조하는 외부 도메인의 DNS 조회를 미리 수행합니다. <br/>
```html
<link rel="dns-prefetch" href="//example.com"> 
```
태그를 사용하여 구현할 수 있습니다.

 <br/>
Prerendering<br/>
Prerendering은 사용자가 다음에 방문할 것으로 예상되는 웹 페이지를 미리 전체적으로 렌더링하여 준비하는 기술입니다. <br/>
이 방법은 단순히 데이터를 미리 다운로드하는 것을 넘어서, <br/>
실제로 페이지를 미리 렌더링하여 사용자가 페이지에 접근하는 순간 즉시 표시할 수 있도록 합니다. <br/>

```html
<link rel="prerender" href="URL"> 
```
태그를 사용하여 구현할 수 있습니다. <br/>
<br/>
Prerendering은 리소스를 많이 사용할 수 있으므로 신중하게 사용해야 합니다.<br/>
<br/>


<br/>
CWV에 미치는 영향<br/>
LCP (Largest Contentful Paint): <br/>
Prerendering을 통해 사용자가 다음 페이지에 접근했을 때, <br/>
주요 콘텐츠가 이미 렌더링되어 있기 때문에 LCP를 크게 개선할 수 있습니다.<br/>
<br/>
FID (First Input Delay): <br/>
Prefetching과 Prerendering은 필요한 리소스를 미리 로드하고 처리함으로써 사용자 상호작용에 대한 응답 시간을 단축시킬 수 있습니다.<br/>


<br/>
CLS (Cumulative Layout Shift): 페이지의 리소스가 미리 로드되어 있으면 레이아웃 변화가 줄어들어 CLS가 개선될 수 있습니다.<br/>
Prefetching과 Prerendering은 사용자 경험을 크게 향상시킬 수 있지만, 사용 시 서버 부하 증가, 사용자의 데이터 사용량 증가 등의 부작용을 고려해야 합니다. <br/>
따라서 이 기술들을 적절하고 효율적으로 사용하는 것이 중요합니다.<br/><br/>


<br/><br/><br/>
14.
FID에 대한 부정적인 영향들

<br/><br/><br/><br/><br/><br/><br/><br/>

"Long tasks"는 브라우저의 주 실행 스레드에서 50ms 이상 실행되는 작업을 말합니다. <br/>
이러한 작업은 웹 페이지의 반응성을 저하시킬 수 있으며, <br/>
사용자 인터페이스가 멈춰 있거나 느리게 반응하는 것처럼 느껴지게 만듭니다. <br/>
이는 Core Web Vitals(CWV) 중 하나인 First Input Delay(FID)에 부정적인 영향을 미칠 수 있습니다. <br/>
FID는 사용자가 페이지와 처음 상호작용할 때부터 브라우저가 해당 상호작용을 처리하기 시작할 때까지의 지연 시간을 측정합니다.<br/>

<br/><br/><br/><br/>
Long Tasks를 피하거나 분할하는 방법
<br/>
1. 코드 분할<br/>
   코드 분할을 사용하여 필요한 기능만 로드하고 실행하도록 합니다. <br/>
   이는 특히 단일 페이지 애플리케이션(SPA)에서 유용할 수 있습니다. <br/>
   예를 들어, 웹팩 같은 모듈 번들러를 사용하여 코드를 여러 청크로 분할하고 필요할 때만 로드할 수 있습니다.<br/>

<br/>
2. 웹 워커 사용<br/>
웹 워커를 사용하여 복잡한 계산이나 데이터 처리 작업을 메인 스레드에서 분리할 수 있습니다. <br/>
웹 워커는 백그라운드 스레드에서 코드를 실행할 수 있게 해주어 UI의 반응성을 유지하면서도 복잡한 작업을 처리할 수 있게 해줍니다.<br/>

<br/>
3. 요청 애니메이션 프레임(requestAnimationFrame)<br/>
**requestAnimationFrame**은 브라우저가 다음 리페인트 전에 애니메이션을 업데이트할 수 있도록 요청하는 방법입니다. <br/>
이를 사용하여 애니메이션 또는 스크롤 이벤트와 같은 작업을 효율적으로 스케줄링할 수 있습니다.<br/>

<br/>
4. 비동기 처리<br/>
비동기 처리를 통해 I/O 작업이나 네트워크 요청 등을 메인 스레드가 아닌 비동기적으로 처리할 수 있습니다. <br/>
이는 Promise나 async/await 구문을 사용하여 구현할 수 있습니다.<br/>

<br/>
5. 타임아웃 및 디바운싱 사용<br/>
사용자 인터랙션을 처리할 때 타임아웃과 디바운싱 기법을 사용하여 연속적인 작업을 제한하거나 일정 시간 후에만 작업을 수행하도록 할 수 있습니다. <br/>
이는 불필요한 작업 수행을 줄이고 메인 스레드의 부하를 경감시킵니다.<br/>

<br/>
6. 성능 프로파일링<br/>
개발 도구를 사용하여 성능 프로파일링을 수행하고, 긴 작업을 식별하여 최적화할 수 있습니다. <br/>
크롬 개발자 도구의 Performance 탭에서는 웹 페이지를 로드하고 실행하는 동안 발생하는 다양한 이벤트와 작업을 시각적으로 확인할 수 있습니다.<br/>
이러한 기법을 적절히 사용하면 웹 페이지의 반응성을 개선하고 사용자 경험을 향상시킬 수 있습니다.<br/>




<br/><br/>
isInputPending(), scheduler.postTask(), 그리고 scheduler.yield()는 <br/>
웹 플랫폼의 태스크 스케줄링 및 입력 반응성과 관련된 기능들입니다. <br/>
이 기능들은 복잡한 계산이나 렌더링 작업 중에도 웹 애플리케이션을 보다 반응적으로 만들어 사용자 경험을 향상시키기 위해 설계되었습니다. <br/>

<br/><br/>
isInputPending()<br/>
목적: 개발자들이 처리되지 않은 사용자 입력(클릭, 탭, 키 입력 등)이 있는지 확인할 수 있게 해주는 API입니다. <br/>
긴 작업을 사용자 입력을 방해하지 않고 작은 청크로 나눌 때 유용합니다.<br/><br/>
사용법: 긴 계산을 수행하는 작업 내에서 주기적으로 사용자 입력이 있는지 확인할 수 있습니다. <br/>
입력이 있다면, 작업을 일시 중지하거나 멈춰서 입력을 처리할 수 있어 페이지가 더 반응적으로 느껴지게 합니다.<br/>

<br/><br/>
scheduler.postTask()<br/>
목적: 스케줄러 API의 일부인 scheduler.postTask()는 특정 우선순위를 가진 태스크를 큐에 넣을 수 있게 해줍니다. <br/>
setTimeout이나 requestAnimationFrame보다 유연하고 강력한 태스크 스케줄링 방법을 제공하여 우선순위 기반 스케줄링이 가능합니다.<br/>
사용법: 개발자들은 'user-blocking', 'user-visible', 'background'와 같은 우선순위로 태스크(실행될 함수)를 스케줄할 수 있습니다. <br/>
이를 통해 브라우저가 태스크의 중요성을 이해하고 페이지 반응성과 효율성을 향상시키는 방식으로 태스크를 스케줄할 수 있게 합니다. <br/>

<br/><br/>
scheduler.yield()<br/>
목적: 이 메서드는 브라우저에 일시적으로 제어권을 양보하여 사용자 입력, 렌더링 등과 같은 고우선순위 태스크를 처리할 수 있게 합니다. <br/>
scheduler.postTask()와 함께 사용하여 보다 복잡한 스케줄링 패턴을 만드는 데 유용합니다.<br/>
사용법: scheduler.postTask()로 스케줄된 긴 실행 태스크 내에서 scheduler.yield()를 호출하면, <br/>
브라우저가 다른 태스크를 처리할 기회를 제공함으로써, 무거운 JavaScript 태스크 실행 중에도 페이지의 반응성을 향상시킬 수 있습니다.<br/>
이 기능들은 개발자들이 태스크 스케줄링과 실행을 더 잘 제어하여 사용자 입력 처리와 사용자 경험에 중요한 태스크의 우선순위를 기반으로 한 <br/>
웹 애플리케이션을 더욱 부드럽고 반응적으로 만들기 위한 노력의 일부입니다.<br/>


<br/><br/>
isInputPending() <br/>
API는 중요한 입력 태스크가 대기 중인지 확인하고, 대기 중인 태스크가 있다면 조기에 양보(yield)할 수 있게 해주는 기능을 제공합니다. <br/>
이 API는 브라우저가 사용자 입력에 더 빠르게 반응할 수 있도록 도와주므로, 웹 애플리케이션의 반응성을 향상시키는 데 유용합니다. <br/>
사용자가 웹 페이지와 상호작용하는 동안 긴 JavaScript 작업이 실행되고 있을 때, <br/>
이 API를 사용하여 사용자 입력이 발생하면 해당 작업을 일시 중지하고 우선적으로 입력을 처리할 수 있습니다.<br/>
<br/>
Chromium 기반 브라우저에서 사용할 수 있는 이 API는 다음과 같은 방식으로 사용됩니다:<br/>
<br/>
확인 작업: navigator.scheduling.isInputPending() 함수를 호출하여 현재 처리되지 않은 사용자 입력이 있는지 확인할 수 있습니다. <br/>
이 함수는 선택적으로 특정 입력 유형에 대해 검사할 수 있는 옵션을 제공합니다.<br/>
<br/>
적응적 작업 분할: 긴 작업을 수행하는 동안 주기적으로 isInputPending()를 호출하여 중요한 사용자 입력이 대기 중인지 확인할 수 있습니다. <br/>
입력이 대기 중이면, 현재 작업을 일시 중지하거나 종료하여 입력 처리에 우선순위를 둘 수 있습니다.<br/>
<br/>
반응성 향상: 이 방식을 사용함으로써, 개발자들은 사용자가 페이지와 상호작용할 때 지연을 최소화하고 더 나은 사용자 경험을 제공할 수 있습니다.<br/>
<br/><br/>
Chromium 기반 브라우저(예: Google Chrome, Microsoft Edge)에서만 사용할 수 있는 이 API는 웹 성능 최적화를 위한 중요한 도구 중 하나로, <br/>
반응성이 중요한 애플리케이션 개발에 매우 유용합니다.<br/>




<br/><br/><br/>



scheduler.postTask() <br/>
API는 개발자들이 우선순위를 가진 태스크를 스케줄할 수 있게 해주는 기능입니다. <br/>
이 API를 통해 브라우저는 더 높은 우선순위의 태스크가 없을 때에만 해당 태스크를 실행할 수 있도록 합니다. <br/>
이는 웹 애플리케이션의 성능을 최적화하고 사용자 경험을 개선하는 데 중요한 역할을 합니다.<br/>
<br/>
scheduler.postTask()는 <br/>
Chromium 기반 브라우저에서 사용할 수 있으며, <br/>
다양한 우선순위 수준을 제공하여 개발자가 태스크의 중요도에 따라 적절하게 관리할 수 있게 합니다. <br/>

우선순위는 다음과 같이 분류됩니다:<br/>

user-blocking: 가장 높은 우선순위로, 즉각적인 사용자 입력에 반응해야 하는 태스크에 사용됩니다.<br/>
user-visible: 사용자에게 보이는 결과를 생성하는 태스크에 사용되며, user-blocking보다는 낮지만 여전히 높은 우선순위를 가집니다.<br/>
background: 사용자에게 직접적으로 보이지 않는 작업에 사용되며, 낮은 우선순위를 가집니다.<br/>
이 API의 사용은 웹 페이지가 복잡한 계산이나 데이터 처리 등의 작업을 수행할 때 사용자 인터페이스가 여전히 반응적으로 유지되도록 돕습니다. <br/>
예를 들어, scheduler.postTask()를 사용하여 배경에서 데이터를 불러오는 작업을 낮은 우선순위로 스케줄하고, <br/>
사용자의 입력을 처리하는 작업을 높은 우선순위로 설정할 수 있습니다.<br/>

Chromium 기반 브라우저에서 제공되는 scheduler.postTask() API는 웹 애플리케이션의 태스크 관리를 더 세밀하게 조정할 수 있게 하여, <br/>
효율적인 성능 최적화와 우수한 사용자 경험을 달성하는 데 기여합니다.<br/>









<br/><br/><br/><br/><br/><br/><br/><br/><br/>
15.

contain에 대해서

CSS의 contain 속성은 웹 개발자가 브라우저의 스타일, 레이아웃, 그리고 페인트 작업의 범위를 제한할 수 있도록 해주는 강력한 도구입니다. <br/>
이 속성을 사용함으로써, 개발자는 특정 요소가 페이지의 나머지 부분에 미치는 영향을 명확히 제한할 수 있으며, <br/>
이는 브라우저가 렌더링을 더 효율적으로 수행하게 만들어 성능을 향상시킬 수 있습니다.<br/>

contain 속성의 값<br/>
none: 기본값으로, 요소가 다른 요소에 영향을 미칠 수 있음을 나타냅니다.<br/>
strict: size, layout, style, paint가 모두 적용됩니다. 이는 요소가 외부 컨텐츠에 영향을 미치지 않고, 외부에서 이 요소에 영향을 미치지 않음을 보장합니다.<br/>
content: layout, style, paint가 적용되며, 이는 strict와 유사하지만, 요소의 크기가 외부 요소에 의해 결정될 수 있음을 의미합니다.<br/>
size: 요소의 크기 계산이 독립적으로 이루어짐을 나타냅니다. 이는 레이아웃 계산 시간을 줄일 수 있습니다.<br/>
layout: 요소 내부의 레이아웃이 외부 레이아웃에 영향을 미치지 않음을 보장합니다.<br/>
style: 요소 내부의 스타일 변경이 외부에 영향을 미치지 않음을 나타냅니다.<br/>
paint: 요소의 그리기 영역이 격리되어, 요소 외부의 페인트 작업에 영향을 미치지 않음을 나타냅니다.<br/>

사용 예시
css
```css
.element {
    contain: layout style;
}
```

이 코드는 .element 내부에서 발생하는 레이아웃과 스타일 변경이 요소 밖에 영향을 미치지 않도록 제한합니다. <br/>
이는 브라우저가 페이지의 다른 부분을 재계산할 필요 없이 해당 요소만을 독립적으로 처리할 수 있게 함으로써 성능을 향상시킬 수 있습니다.<br/>

장점<br/>
성능 향상: contain 속성을 적절히 사용하면 레이아웃, 페인트, 스타일 계산이 필요한 영역을 제한함으로써 브라우저의 작업 부하를 줄일 수 있습니다.<br/>
렌더링 최적화: 특정 요소의 렌더링이 페이지의 나머지 부분과 독립적으로 이루어지도록 함으로써, 전체 페이지의 렌더링 시간을 단축시킬 수 있습니다.<br/>
contain 속성은 복잡한 웹 애플리케이션의 성능을 최적화하는 데 매우 유용한 CSS 속성입니다. <br/>
그러나 이 속성을 사용할 때는 페이지 레이아웃에 미칠 수 있는 영향을 주의 깊게 고려해야 합니다.<br/>


<br/><br/>

16.

content-visibility에 대해서

content-visibility 속성일 것입니다. <br/>
이 속성은 성능 최적화를 위해 Chromium 기반 브라우저에서 도입되었습니다. <br/>
여기에 대해 자세히 설명하겠습니다:<br/>

content-visibility<br/>
content-visibility CSS 속성은 웹 개발자가 브라우저의 레이아웃 및 렌더링 작업을 요소에 대해 완전히 건너뛸 수 있게 해줍니다. <br/>
이를 통해 성능을 크게 향상시킬 수 있으며, 특히 큰 문서를 다룰 때 유용합니다.<br/>
<br/><br/>
속성 값<br/>
visible: 기본값으로, 요소가 정상적으로 렌더링됩니다.<br/>
hidden: 요소와 그 자손의 레이아웃, 렌더링, 페인트가 완전히 건너뛰어집니다. <br/>
이 요소가 화면에 보여야 할 필요가 있을 때까지 브라우저는 이를 렌더링하지 않습니다.<br/>
auto: 브라우저가 요소의 내용을 사용자 화면에 보여줄지 여부를 결정합니다. <br/>
이는 hidden과 유사하지만, 사용자에게 보여질 내용이 있는 경우에만 요소를 렌더링합니다.<br/>
사용 예시

```css
.section {
    content-visibility: auto;
}
```
이 코드는 .section 클래스를 가진 요소의 내용이 사용자 화면에 필요할 때만 렌더링되도록 합니다. <br/>
이는 브라우저가 초기 레이아웃과 렌더링 과정에서 해당 요소를 건너뛰게 하여, 페이지 로딩 시간을 단축시킬 수 있습니다.<br/>
<br/><br/><br/>
장점
성능 향상: 페이지의 특정 부분을 건너뛰어 레이아웃과 렌더링 시간을 줄일 수 있습니다.<br/>
자원 사용 최적화: 사용자에게 현재 보이지 않는 내용의 렌더링을 연기함으로써, 브라우저의 메모리 사용량과 CPU 사용량을 줄일 수 있습니다.<br/>
content-visibility 속성은 큰 웹 페이지나 복잡한 레이아웃을 가진 애플리케이션의 성능을 개선하는 데 매우 유용합니다. <br/>
그러나 이 속성을 사용할 때는 페이지의 사용성과 접근성에 미치는 영향을 신중하게 고려해야 합니다.<br/>


<br/>

제공된 주석에서는 requestAnimationFrame (rAF) 콜백을 웹 개발에서 사용하는 최선의 방법에 대한 지침을 제시합니다. <br/>
rAF는 개발자가 브라우저가 다시 그리기를 수행하기 전에 다음 프레임에서 코드를 실행할 수 있게 해주는 강력한 브라우저 API로, <br/>
부드러운 애니메이션을 가능하게 합니다. <br/>
그러나 사용 방법에 따라 웹 페이지의 성능과 반응성에 큰 영향을 미칠 수 있습니다. 지침을 구체적으로 살펴보겠습니다.<br/>
<br/><br/><br/>
처리량이 많은 업데이트
```javascript
function complexCalculations(time) {
    // 여기서 비시각적 업데이트를 수행합니다.
}
requestAnimationFrame(complexCalculations);
```
주석에서는 처리량이 많은 업데이트에 requestAnimationFrame을 사용하지 말 것을 권장합니다. <br/>
이는 rAF가 시각적 업데이트를 위한 것이며, 이를 무거운 계산 작업에 사용하면 프레임 렌더링이 지연되어 부드럽지 않은 경험을 초래할 수 있기 때문입니다. <br/>
처리량이 많은 작업은 프레임 레이트와 반드시 일치할 필요가 없으며, <br/>
메인 스레드를 차단하지 않기 위해 Web Worker로 오프로드하거나 setTimeout 또는 setInterval을 사용해 작은 청크로 나누어 스케줄링할 수 있습니다.<br/>
<br/>
<br/>
<br/>
중요한 렌더링 업데이트
```javascript
function updateScreen(time) {
    // 여기서 시각적 업데이트를 수행합니다.
}
requestAnimationFrame(updateScreen);
```
여기서는 중요한 렌더링 업데이트에 requestAnimationFrame을 사용할 것을 권장합니다. <br/>

<br/><br/><br/><br/><br/><br/><br/><br/>
이는 rAF의 이상적인 사용 사례로, 이러한 업데이트를 브라우저의 그리기 주기와 동기화하여 시각적 찢어짐이나 덜컹거림의 가능성을 최소화할 수 있습니다. <br/>
이를 통해 애니메이션 또는 전환과 같은 시각적 변경사항이 가능한 한 부드럽게 진행되도록 하여 사용자 경험을 향상시킬 수 있습니다.<br/>
<br/>
<br/>
요약 및 최선의 방법<br/>
애니메이션과 시각적 업데이트에는 requestAnimationFrame을 사용하세요. <br/>
이는 브라우저의 다시 그리기 주기와 동기화되어야 하며 부드러워야 하는 작업에 적합합니다.<br/>
무거운 비시각적 작업에는 requestAnimationFrame을 사용하지 마세요. <br/>
이는 애니메이션의 성능을 저하시키거나 페이지의 반응성을 떨어뜨릴 수 있습니다. <br/>
대신, 복잡한 계산을 메인 스레드에서 오프로드하기 위해 Web Worker를 사용하거나, <br/>
덜 중요하고 시간이 많이 걸리는 작업에 setTimeout/setInterval을 고려하세요.<br/>
성능을 모니터링하세요.<br/> <br/>

특히 복잡한 웹 애플리케이션에서 requestAnimationFrame 사용의 성능 영향을 항상 테스트하고 모니터링하세요. <br/>
Chrome DevTools의 성능 탭과 같은 도구를 사용하면 병목 현상을 식별하고 애니메이션 및 업데이트가 효율적으로 구현되었는지 확인할 수 있습니다.<br/>