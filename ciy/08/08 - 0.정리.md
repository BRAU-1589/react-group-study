8.1 useState
8.2 useEffect
8.3 useReducer
8.4 useMemo
8.5 useCallback
8.6 useRef
8.7 커스텀 Hooks 만둘기
8.8 다른 Hooks
8.9 정리


8장에서 다룰 Hooks는 기존의 함수 컴포넌트에서 할 수 없었던 다양한 작업(함수 컴포넌트에서 상태 관리하기, <br/>
렌더링 직후 작업 설정하기 등)을 할 수 있게 합니다. 이는 리액트 v16.8에 새로 도입. <br/>





















action.type을 사용하는 이유는 <br/>
action 객체가 어떤 종류의 작업을 수행해야 하는지를 식별하기 위해서입니다.<br/>
이 코드는 리듀서 함수의 예시로, <br/>
리덕스(Redux) 또는 리액트 컨텍스트와 유사한 상태 관리 패턴에서 주로 사용됩니다.<br/>
리듀서 함수는 현재 상태(state)와 action 객체를 매개변수로 받아, <br/>
주어진 action의 종류에 따라 상태를 변경하고 새로운 상태를 반환합니다.<br/>

action 객체는 일반적으로 최소한 type 속성을 포함하며, <br/>
이 type 속성은 리듀서가 어떤 작업을 수행해야 하는지를 나타내는 식별자입니다. <br/>
예를 들어, type이 'increment'인 경우 카운트를 증가시키고, 'decrement'인 경우 카운트를 감소시킵니다. <br/>
default 케이스는 주어진 action이 처리할 수 없는 타입일 경우 현재 상태를 그대로 반환하여 상태가 변경되지 않도록 합니다.<br/>
<br/>
따라서, action.type을 사용하는 것은 리듀서 함수 내에서 다양한 작업을 구분하고 <br/>
적절한 상태 변경 로직을 수행하기 위한 필수적인 방법입니다.<br/>



useReducer는 복잡한 상태 로직이 있는 구성 요소와 여러 하위 값이 있는 상태를 처리할 때 더 적합. <br/>
복잡한 상태 상호 작용을 처리하는 보다 구조화된 방법을 제공하므로 리듀서 기능을 통해 예측 가능한 방식으로 상태 전환을 관리할 수 있습니다.<br/>
<br/>

useState는 간단한 텍스트 입력 상태 관리에 더 적합. <br/>
텍스트 입력 값 처리와 같이 상태 논리가 최소인 시나리오에 대해 기능 구성 요소의 상태를 관리하는 간단하고 직접적인 방법을 제공합니다.<br/>
<br/>

여러 개의 상태 값이 서로 종속되어 있는 경우에는 useReducer를 사용하는 것이 좋다. <br/>
이 후크는 상태 논리를 리듀서 함수에 중앙 집중화하여 여러 상태 변수가 서로 상호 작용하거나 의존할 때 <br/>
상태 관리를 단순화하여 복잡한 상태 관계를 더 쉽게 이해하고 유지 관리할 수 있도록 합니다.<br/>

<br/>
상태 업데이트 로직을 구성 요소 외부에서 분리하고 싶지 않은 경우 useState를 사용. <br/>
'useState'를 사용하면 구성 요소 내에서 직접 상태를 업데이트하여 상태 관리를 구성 요소의 논리 및 렌더링과 밀접하게 연결하여 유지할 수 있으므로 <br/>
더 간단한 상태 관리 시나리오에 적합할 수 있습니다.<br/>





"useCallback은 주로 계산 비용이 높은 값의 계산 결과를 기억하여 성능을 향상시키는 데 사용됩니다."<br/>

이 문은 useCallback의 목적을 잘못 설명합니다. <br/>
실제로 useCallback은 특히 함수가 하위 구성 요소에 props로 전달될 때 불필요한 다시 렌더링을 방지하기 위해 함수를 메모하도록 설계되었습니다. <br/>
값의 계산 결과를 기억하지 않습니다. <br/>
이것이 useMemo의 목적입니다. <br/>
'useMemo'는 비용이 많이 드는 계산 결과를 메모하고 종속성 중 하나가 변경된 경우에만 다시 계산하여 성능을 향상시키는 데 사용되는 후크입니다.<br/>








console.log(name)에 찍힐 값은 'Taylor'입니다.<br/>
<br/>
React의 useState 훅을 사용할 때, 상태 업데이트 함수(예: setName)를 호출하더라도 상태 값이 바로 업데이트되지 않습니다.<br/>
상태 업데이트는 비동기적으로 이루어지며, 컴포넌트의 다음 렌더링 시점에 새로운 상태 값이 반영됩니다.<br/>
따라서 setName('Robin')을 호출한 직후에 console.log(name)을 실행하면, 업데이트가 아직 반영되지 않은 상태의 name 값, 즉 'Taylor'가 출력됩니다.<br/>
<br/>
React에서 상태 업데이트가 비동기적으로 작동하는 것은 성능 최적화와 관련이 있습니다.<br/>
이는 React가 여러 상태 업데이트를 배치로 처리하여 불필요한 렌더링을 최소화하기 위함입니다.<br/>



유사점<br/>
의존성 배열: 두 훅 모두 두 번째 인자로 의존성 배열을 받습니다. <br/>
배열 내의 값들이 변경될 때만 첫 번째 인자로 전달된 함수를 다시 실행합니다.<br/>
<br/>
조건부 실행: <br/>
의존성 배열의 값이 변경되지 않는 한, 메모이제이션된 값이나 함수를 재사용함으로써 불필요한 계산이나 렌더링을 방지합니다.<br/>
차이점<br/>
목적과 사용 사례:<br/>

useMemo는 계산된 값을 메모이제이션하는 데 사용됩니다. <br/>
예를 들어, 복잡한 계산 결과, 무거운 함수의 반환 값 등을 메모리에 저장해 놓고<br/>
의존성 배열의 값이 변경될 때만 해당 연산을 다시 수행합니다.<br/>

useCallback은 함수 자체를 메모이제이션하는 데 사용됩니다. <br/>
이는 주로 자식 컴포넌트에 함수를 props로 전달할 때 유용하며, <br/>
의존성 배열 내의 값이 변경될 때만 함수를 다시 생성합니다. <br/>
이는 불필요한 자식 컴포넌트의 렌더링을 방지하는 데 도움이 됩니다.<br/>
반환 값:<br/>

useMemo는 메모이제이션된 값을 반환합니다.<br/>
useCallback은 메모이제이션된 함수를 반환합니다.<br/>


제공하신 구문은 유효한 JavaScript 또는 React 코드가 아니지만, <br/>
종속성 배열을 올바르게 지정하지 않고 'useMemo' <br/>
후크 내에서 평균값을 계산하는 것이 비효율적이라고 문의하신 것으로 알고 있습니다. <br/>
올바른 접근 방식과 언급한 방법이 비효율적이라고 간주되는 이유에 대해 논의해 보겠습니다.<br/>

React에서 'useMemo'는 비용이 많이 드는 계산을 메모하는 데 사용되는 후크입니다. <br/>
함수와 종속성 배열을 인수로 사용합니다. <br/>
이 함수는 구성 요소가 탑재될 때와 종속성 배열의 값이 변경될 때마다 실행됩니다. <br/>
평균을 계산하기 위해 useMemo를 사용하는 보다 정확한 방법은 다음과 같습니다.<br/>