key

리액트에서 key란 컴포넌트 배열을 렌더링 했을 때, <br>
어떤 원소에 변동이 있었는지 알아내는 값이다. <br>
key값은 언제나 유일해야 한다.


```javascript
import React from 'react';
 
const IterationSample = () => {
  const names = ['눈사람', '얼음', '눈', '바람'];
  const namesList = names.map((name, index) => <li key={index}>{name}</li>);
  return <ul>{namesList}</ul>;
};
 
export default IterationSample;
```


이 예시에서는 반복하는 배열이 고유한 번호를 가지고 있지 않았기 때문에, 배열 names의 index를 이용하였다. 

하지만 이러한 방법은 배열이 변경될 때 효율적이지 못하다는 단점이 있다.

<br><br>


key값을 효율적으로 관리하고, <br>
더불어 동적인 배열을 렌더링 하는 예시를 만들어본다. <br>
동적으로 렌더링 하기 위해 useState를 이용하여 상태를 설정한다.

```javascript
import React, { useState } from 'react';
 
const IterationSample = () => {
  const [names, setNames] = useState([ //데이터 배열
    { id: 1, text: '눈사람' },
    { id: 2, text: '얼음' },
    { id: 3, text: '눈' },
    { id: 4, text: '바람' }
  ]);
  const [inputText, setInputText] = useState(''); //텍스트를 입력할 input 상태
  const [nextId, setNextId] = useState(5); //고유 id / 새로운 항목을 추가할 때 사용할 id
 
  const namesList = names.map(name => <li key={name.id}>{name.text}</li>);
  return <ul>{namesList}</ul>;
};
 
export default IterationSample;


```
 
출력시

- 눈사람
- 얼음
- 눈
- 바람




useState를 세 번 사용했는데, <br>
순서대로 데이터 배열, 텍스트를 입력할 input 상태, 고유 id이다. <br>이제 고유 id를 이용하여 index대신 key값을 설정한다.<br>


상태 관리 (useState)<br>

names: 데이터 배열로, 각 항목은 고유한 id와 표시할 텍스트 text를 가진 객체. 이 배열은 UI에 표시될 데이터를 담고 있다.

```javascript
const [names, setNames] = useState([
  { id: 1, text: '눈사람' },
  { id: 2, text: '얼음' },
  { id: 3, text: '눈' },
  { id: 4, text: '바람' }
]);
```

inputText: 사용자가 입력할 텍스트를 관리하는 상태. 이 상태는 현재 예제에서는 직접적으로 사용되지 않지만, 추후 사용자 입력을 처리하는 데 사용될 수 있다.

```javascript
const [inputText, setInputText] = useState('');
```

nextId: 새로운 항목을 추가할 때 사용할 고유한 ID를 관리한다. 현재 예제에서는 이 ID도 사용되지 않지만, 새 항목을 추가할 때 고유한 ID를 부여하는 데 사용될 수 있다.
```javascript
const [nextId, setNextId] = useState(5);
```

<br><br>
리스트 렌더링

namesList: names 배열의 각 항목을 순회하면서 (map 함수 사용), 

리스트 아이템 ```(<li>)```으로 변환합니다. 
각 ```<li>``` 요소는 고유한 key 속성을 갖고 있으며, 이는 React가 리스트를 효율적으로 렌더링하는 데 도움을 줍니다.

```javascript
const namesList = names.map(name => <li key={name.id}>{name.text}</li>
```


<br><br><br>

ex2)
```javascript
function MemoApp() {
  const [memos, setMemos] = useState([]);
  const [memoText, setMemoText] = useState("");
  const [nextId, setNextId] = useState(1);

  const addMemo = () => {
    if(memoText !== "") {
      // 새 메모 객체를 생성
      const newMemo = { id: nextId, text: memoText };

      // 새 메모를 배열에 추가
      const updatedMemos = memos.concat(newMemo);

      // 상태를 업데이트
      setMemos(updatedMemos);
      setMemoText("");
      setNextId(nextId + 1);
    }
  };

  return (
    <div>
      <input type="text" value={memoText} onChange={(e) => setMemoText(e.target.value)} />
      <button onClick={addMemo}>Add Memo</button>
      <ul>
        {memos.map(memo => (
          <li key={memo.id}>{memo.text}</li>
        ))}
      </ul>
    </div>
  );
}
```

상태 관리 (useState)<br>

memos: 이 상태는 메모 목록을 나타내는 배열이다. <br> 
각 메모는 객체로 표현되며, id와 text 속성을 가진다. <br> 
이 배열은 UI에 표시될 데이터를 담고 있다.

```javascript
const [memos, setMemos] = useState([]);
```
<br>
memoText: 사용자가 입력할 메모 텍스트를 관리하는 상태. <br> 
이 상태는 새 메모를 추가할 때 사용된다.

```javascript
const [memoText, setMemoText] = useState("");
```
<br>

nextId: 새로운 메모를 추가할 때 사용할 고유한 ID를 관리한다.<br> 
이 ID는 각 메모를 구별하는 데 사용된다.
```javascript
const [nextId, setNextId] = useState(1);
```


메모 추가 기능 (addMemo 함수)<br>


addMemo 함수: 이 함수는 사용자가 'Add Memo' 버튼을 클릭할 때 호출된다.

함수 동작 수행:

메모 객체 생성: memoText에서 가져온 텍스트와 nextId를 사용하여 새로운 메모 객체를 만든다.

목록 업데이트: 새로운 메모 객체를 기존 memos 배열에 추가한다. 이때 concat 메서드를 사용하여 기존 배열에 새 객체를 추가한다.

메모를 추가한 후, memoText는 빈 문자열로 초기화되고, nextId는 1 증가합니다.






<br><br>



ex3)
```javascript
function TodoListApp() {
  const [todos, setTodos] = useState([]);
  const [inputText, setInputText] = useState("");
  const [nextId, setNextId] = useState(0);

  const addTodo = () => {
    if (inputText !== "") {
      // 새로운 할 일 객체 생성
      const newTodo = { id: nextId, text: inputText };

      // 새로운 할 일을 목록에 추가
      setTodos([...todos, newTodo]);

      // 입력 필드 초기화 및 ID 증가
      setInputText("");
      setNextId(nextId + 1);
    }
  };

  return (
    <div>
      <input 
        type="text" 
        value={inputText} 
        onChange={(e) => setInputText(e.target.value)} 
      />
      <button onClick={addTodo}>Add Todo</button>
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </div>
  );
}
```

<br><br>

상태 관리 (useState)<br>

todos: 이 상태는 할 일 목록을 나타내는 배열입니다.<br> 
각 할 일은 객체로 표현되며, id와 text 속성을 가진다.

```javascript
const [todos, setTodos] = useState([]);
```
<br>
inputText: 사용자가 입력 필드에 입력하는 텍스트를 관리하는 상태이다.<br>  이 값은 할 일을 추가할 때 사용된다.

```javascript
const [inputText, setInputText] = useState("");
```
<br>

nextId: 각 할 일 항목에 부여될 고유한 ID를 관리하는 상태입니다.<br>  이 ID는 할 일을 구별하는 데 사용된다.
```javascript
const [nextId, setNextId] = useState(0);
```
<br><br>

핵심 기능 (addTodo 함수)<br>


addTodo 함수: 이 함수는 사용자가 'Add Todo' 버튼을 클릭할 때 호출된다.

함수 동작 수행:

할 일 객체 생성: inputText에서 가져온 텍스트와 nextId를 사용하여 새로운 할 일 객체를 만든다.

목록 업데이트: 새로운 할 일 객체를 기존 todos 배열에 추가합니다. 이때 ... (스프레드 문법)을 사용하여 기존 배열에 새 객체를 추가한다.

상태 초기화: 할 일을 추가한 후, inputText는 빈 문자열로 초기화되고, nextId는 1 증가한다.