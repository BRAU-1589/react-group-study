콜백 함수
서버 API를 호출할 때 외에도 setTimeout 함수를 사용하여 특정 작업을 예약할 때에도 비동기적 방식을 사용한다.

function printMe() {
console.log('Hello World!');
}
setTimeout(printMe, 3000);
콜백 함수
서버 API를 호출할 때 외에도 setTimeout 함수를 사용하여 특정 작업을 예약할 때에도 비동기적 방식을 사용한다.

function printMe() {
console.log('Hello World!');
}
setTimeout(printMe, 3000);
console.log('대기 중...');
실행 결과

대기 중...
Hello World!
setTimeout이 사용될 때 코드가 3초 동안 멈추는 것이 아니라, 일단 코드가 위부터 아래까지 다 호출되고(console.log까지 동시에) 3초 뒤에 실행하라고 한 printMe가 호출되었다.

이런 비동기 처리 방식을 콜백 함수라고 한다. 3초 뒤에 호출되도록 printMe 함수 자체를 setTimeout 함수의 인자로 전달해 주는 것!

function increase(number, callback) {
setTimeout(() => {
const result = number + 10;
if (callback) {
callback(result);
}
}, 1000)
}


increase(0, result => {
console.log(result);
});
위 코드에서는 1초 뒤에 10을 더해서 반환하는 함수를 정의하고 콜백함수로 값을 넘겨주고 있다. 하지만 1초 간격으로 여러 번 호출해서 콜백을 중첩한다면?

console.log('작업 시작');
increase(0, result => {
console.log(result);
increase(result, result => {
console.log(result);
increase(result, result => {
console.log(result);
increase(result, result => {
console.log(result);
console.log('작업 완료');
});
});
});
});
...이런 걸 콜백 지옥이라고 부른다.

Promise
콜백 지옥 같은 코드가 형성되지 않게 하는 방안으로 ES6에 도입된 것이 바로 Promise다. 여러 작업을 연달아 사용할 때 .then을 사용하기 때문에 콜백 지옥이 형성되지 않는다.

function increase(number) {
const promise = new Promise((resolve, reject) => {
// resolve는 성공, reject는 실패
setTimeout(() => {
const result = number + 10;
if (result > 50) {
// 50보다 높으면 에러 발생시키기
const e = new Error('NumberTooBig');
return reject(e);
}
resolve(result); // number 값에 +10 후 성공 처리
}, 1000);
});
return promise;
}

increase(0)
.then(number => {
// Promise에서 resolve된 값은 .then을 통해 받아 올 수 있음
console.log(number);
return increase(number); // Promise를 리턴하면
})
.then(number => {
// 또 .then으로 처리 가능
console.log(number);
return increase(number);
})
.then(number => {
console.log(number);
return increase(number);
})
.then(number => {
console.log(number);
return increase(number);
})
.then(number => {
console.log(number);
return increase(number);
})
.catch(e => {
// 도중에 에러가 발생한다면 .catch를 통해 알 수 있음
console.log(e);
});
async/await
async/await는 Promise를 더욱 쉽게 사용할 수 있도록 해 주는 ES8 문법이다. 이 문법을 사용하려면 함수의 앞부분에 async 키워드를 추가하고, 해당 함수 내부에서 Promise의 앞부분에 await 키워드를 사용하면 된다. 이렇게 하면 Promise가 끝날 때까지 기다리고, 결과 값을 특정 변수에 담을 수 있다.

function increase(number) {
const promise = new Promise((resolve, reject) => {
// resolve는 성공, reject는 실패
setTimeout(() => {
const result = number + 10;
if (result > 50) { // 50보다 높으면 에러 발생시키기
const e = new Error(‘NumberTooBig‘);
return reject(e);
}
resolve(result); // number 값에 +10 후 성공 처리
}, 1000)
});
return promise;
}


async function runTasks() {
try { // try/catch 구문을 사용하여 에러를 처리합니다.
let result = await increment(0);
console.log(result);
result = await increment(result);
console.log(result);
result = await increment(result);
console.log(result);
result = await increment(result);
console.log(result);
result = await increment(result);
console.log(result);
result = await increment(result);
console.log(result);
} catch (e) {
console.log(e);
}
}


