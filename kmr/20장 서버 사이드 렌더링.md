# CSR : ClientSideRendering
## 간략한 CSR 로드 순서
1. 서버에서 빈 뼈대 HTML과, 연결된 JS 링크를 보내준다. 
<br/>-> 서버 측 부하가 적고, 반응 속도가 빨라 사용자 경험이 좋아진다. 하지만 SEO에 불리하다.<br/>
2. 브라우저는 JS를 다운로드 한다.
<br/>-> 다운로드가 오래 걸릴수록 유저가 첫 화면을 보기 까지 시간이 걸린다.<br/>
3. 그리고 JS를 이용해 동적 DOM을 생성한다.
<br/>-> 초기 로딩 속도가 느리다. JS로 화면을 전부 구성할 때까지 유저에겐 화면이 보이지 않는다.

### CSR 로드의 단점
![](https://velog.velcdn.com/images/mimizl/post/76444ba0-8c0b-42a2-ab45-da03b8bae805/image.png)
웹서버에서 HTML을 받은 후 필요한 CSS, JS를 다운받는다.<br/>
SPA + CSR 프레임인 리액트의 경우 index.html의 body 태그 안에는
`<div id="root"/>`만 있는게 대부분이고 실질적인 화면 구성은 리액트가 JS를 이용해서 한다.
```javascript
const container = document.getElementById('root');
const root = createRoot(container);
root.render(<App />);
```
DOM도 JS가 구성하고 스타일도 CSS in JS 쓰는 등 JS의 연산을 기다리는 시간이 길어지게 됐다.

### CSR 단점 보완 방법

- code-splitting, tree-shaking, chunk 분리 등 JS 번들 크기를 줄여서 초기 로딩 속도를 줄일 수 있다.<br/>
- 프리 렌더링을 통해 페이지에 대한 HTML을 미리 생성해 둔 뒤 크롤러의 요청이 있는 경우 사전에 렌더링된 HTML을 보낼 수도 있다<br/>
  `프리 렌더링 :`
#### CSR에 SSR/SSG을 도입하는 방법
프레임워크를 사용할 수 있다.<br/>
NEXT.js : 리액트에서 SSR이나 SSG를 사용할 수 있게 해주는 프레임워크다.
Gatsby : SSG에 최적화, 다양한 플러그인, 빌드 시점에 HTML들을 만들어줘서, 페이지가 적고 작은 서비스에 좋다.
NUXT.js: 뷰 프레임워크다.

#### 초기 렌더링 방식으로 SSR, 그 이후로 CSR을 사용하는 방법
- Isomeorphic(같은 모양의, 동일 구조의, 등정형의) App,<br/>
  서버와 클라이언트 사이드 둘 다에서 동작하는 코드로 구성된 웹 앱이다.<br/>
  처음에 방문했을 때는 코드를 모두 로딩하고, 이후 반문 시에는 캐싱해둔 코드를 사용한다. Next.js를 사용하면 쉽게 Isomorphic 리액트 웹앱을 만들 수 있다.<br/>
  서버로부터 가져오는 SEO의 유리함과, 복잡한 유저 상호작용을 처리할 수 있는 브라우저의 능력이 결합되었다.<br/>
1. 초기 렌더링 요청
   컨텐츠가 서버에서 브라우저로 보내지기 때문에 빠르다.
2. 초기 렌더링 이후의 요청
   페이지 첫 렌더링 이후 유저 상호작용은 CSR에서 SPA기법으로 처리된다.
3. 서버에서의 상태 관리
<br/>
- Universal Rendering


# SSR : ServerSideRendering
## 간략한 SSR 로드 순서
1. 서버에서는 렌더링 준비를 마친 HTML, JS코드를 클라이언트로 보내준다.
<br/>-> 최종적으로 완성된 HTML을 전달받아서 SEO에 좋다.<br/>
2. 브라우저는 전달받은 페이지를 바로 띄운다.
<br/>-> 초기 구동 속도가 빠르다. 하지만 이 때 인터렉션이 전혀 되지 않는다.<br/>
3. 그리고 브라우저는 JS코드를 다운받는다.<br/>
4. 다운 후 HTML에 JS 로직을 연결한다. -> 이 시점부터 사용자의 입력에 응답할 수 있다.<br/>


## 서버 사이드 렌더링의 장점
1. **SEO에 좋다.**<br/>
구글, 네이버 등 검색 엔진이 우리가 만든 웹 애플리케이션의 페이지를 원활하게 수집할 수 있다.<br/>
   리액트로 만든 SPA는 검색 엔진 크롤러 봇처럼 자바스크립트가 실행되지 않는 환경에서는 페이지가 제대로 나타나지 않는다.<br/>
   따라서 서버에서 클라이언트 대신 렌더링을 해 주면 검색 엔진이 페이지의 내용을 재대로 수집해 갈 수 있다.<br/>
    (구글 검색 엔진은 자바스크립트를 실행하는 기능이 탑재되어 있어서 크롤링해 갈 때도 있지만 모든 페이지에 대해 자바스크립트를 실행해 주지는 않는다.
    따라서 웹 서비스의 검색 엔진 최적화를 위해서라면 서버 사이드 렌더링을 구현해 주는 것이 좋다.)
<br/>

2. **초기 렌더링 성능 개선**<br/>
또한 서버 사이드 렌더링을 통해 초기 렌더링 성능을 개선할 수 있다.<br/>
   서버 사이드 렌더링이 구현되지 않은 웹 페이지에 사용자가 방문하면, 자바스크립트가 로딩되고 실행될 때까지 사용자는 비어 있는 페이지를 보며 대기해야 한다.<br/>
여기에 API까지 호출해야 한다면 사용자의 대기 시간이 더더욱 길어진다.<br/>
   반면 서버 사이드 렌더링을 구현한 웹 페이지라면 자바스크립트 파일 다운로드가 완료되지 않은 시점에서도 html상에 사용자가 볼 수 있는 콘텐츠가 있기 때문에 대기 시간이 최소화되고, 이로 인해 사용자 경험도 향상된다.<br/>

## 서버 사이드 렌더링의 단점
1. **서버 리소스 사용 및 서버 과부하 위험**<br/>
라우저가 해야 할 일을 서버가 대신 처리하는 것이므로 서버 리소스가 사용된다는 단점이 있다.<br/>
   갑자기 수많은 사용자가 동시에 웹 페이지에 접속하면 서버에 과부하가 발생할 수 있다. 따라서 사용자가 많은 서비스라면 캐싱과 로드 밸런싱을 통해 성능을 최적화해 주어야 한다.<br/>

    `로드 밸런싱 : 애플리케이션을 지원하는 리소스 풀 전체에 네트워크 트래픽을 균등하게 배포하는 방법`
    <br/>

2. **TTV(TimeToView)와 TTI(TimeToInteraction)간 시간 간격 존재**<br/>
  사용자가 버튼을 클릭하거나 이동하려고 해도 아무런 반응이 없을 수 있다.<br/>
  내용과 스타일이 입혀진 껍데기.<br/>
  클라이언트측 js가 실행되어 이벤트핸들러가 붙는 시점에 입력에 응답할 수 있다.<br/>
  화면이 보이지만 움직일 수 없다.<br/>
3. 페이지 별로 분할되어 전송되므로 첫 페이지 로딩 속도가 빠르지만, 페이지 전환 시 깜빡임이 있고 느리다.<br/>



## 서버 사이드 렌더링과 코드 스플리팅 충돌
별도의 호환 작업 없이 두 기술을 함께 적용하면 페이지에서 깜빡임이 발생한다.<br/>
이런 이슈를 해결하려면 라우트 경로마다 코드 스플리팅된 파일 중에서 필요한 모든 파일을 브라우저에서 렌더링하기 전에 미리 불러와야 한다.<br/>
Loadable Components 라이브러리에서 제공하는 기능을 써서 서버 사이드 렌더링 후 필요한 파일의 경로를 추출해 렌더링 결과에 스크립트/스타일 태그를 삽입해주는 방법으로 이 문제점을 해결할 수 있다.<br/>


## SSR과 SSG의 차이
SSR : ServerSideRendering : 서버에서 요청 시에 즉시 만들어줌. 데이터가 달라져서 미리 만들어두기 어려운 페이지에 적합함!<br/>
SSG : StaticSiteGeneration : 만들어둔 뒤에 바뀔 일이 거의 없는 페이지에 적합. 캐싱해두면 좋은 페이지에 좋다!

# 언제 뭘 쓰는게 좋을까?
CSR : 유저와 상호작용이 많거나, 고객 개인 정보로 이루어진 페이지들이라 검색 엔진에 노출될 필요가 없을 때<br/>
SSR : 회사홈페이지, 데이터가 자주 바뀔 때, 누구에게나 항상 같은 내용을 보여줄 때<br/>
SSG : 회사 홈페이지, 누구에게나 항상 같은 내용, 업데이트 거의 없을 때<br/>
CSR + SSR : 사용자에 따라서 다른 페이지, 빠른 인터렉션과 화면 깜빡임 없음, 상위 노출 필요<br/>
<br/>-> 유니버셜 렌더링(초기 로딩시에는 SSR처럼 작동하고 그 이후에는 CSR로 작동하는 방식)


